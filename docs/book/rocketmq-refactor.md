# 进度
- [x] 第1章 Clean-RocketMQ
  - [x] 1.1 站到巨人肩上
  - [x] 1.2 To Clean
  - [x] 1.3 With Clean
- [x] 第2章 优化重构思考
  - [x] 2.1 面向同事，简洁为本
    - [x] 2.1.1 接口第一，慎重命名
    - [x] 2.1.2 目标简洁，无限逼近
    - [x] 2.1.3 风险驱动，识别边界
  - [x] 2.2 多维解耦，死守边界
    - [x] 2.2.1 业务解耦，职责收敛
    - [x] 2.2.2 技术解耦，专事专办
    - [x] 2.2.3 框架沉淀，大隐于市
  - [x] 3.3 文化驱动，设计先行
    - [x] 3.3.1 开源江湖，代码永生
    - [x] 3.3.2 通用语言，设计先行
    - [x] 3.3.3 工匠精神，持续迭代
  - [x] 3.4 无责猜想 未来不远
    - [x] 3.4.1 云原生
    - [x] 3.4.2 主从优化思考
    - [x] 3.4.3 延时优化思考
    - [x] 3.4.4 可延时的事务
    - [x] 3.4.5 注册中心思考
    - [x] 3.4.6 性能进化体系
    - [x] 3.4.7 软件工程实践
    - [x] 3.4.8 设计思想沉淀
    - [x] 3.4.9 质量评估思考
    - [ ] 3.4.10 rust-rocketmq
- [ ] 3 核心流程
  - [ ] 3.1 消息发送流程
    - [ ] 3.1.1 功能用例
    - [ ] 3.1.2 接口测试
    - [ ] 3.1.3 数据流程
    - [ ] 3.1.4 全局流程
    - [ ] 3.1.5 模块职责
    - [ ] 3.1.6 线程模型
    - [ ] 3.1.7 模块流程
    - [ ] 3.1.8 流程总结
  - [ ] 3.2 消息订阅流程
    - [ ] 3.2.1 功能用例
    - [ ] 3.2.2 接口测试
    - [ ] 3.2.3 数据流程
    - [ ] 3.2.4 全局流程
    - [ ] 3.2.5 模块职责
    - [ ] 3.2.6 线程模型
    - [ ] 3.2.7 模块流程
    - [ ] 3.2.8 流程总结
  - [ ] 3.3 消息ACK流程
    - [ ] 3.3.1 功能用例
    - [ ] 3.3.2 接口测试
    - [ ] 3.3.3 数据流程
    - [ ] 3.3.4 全局流程
    - [ ] 3.3.5 模块职责
    - [ ] 3.3.6 线程模型
    - [ ] 3.3.7 模块流程
    - [ ] 3.3.8 流程总结
  - [ ] 3.4 事务消息
    - [ ] 3.4.1 功能用例
    - [ ] 3.4.2 接口测试
    - [ ] 3.4.3 数据流程
    - [ ] 3.4.4 全局流程
    - [ ] 3.4.5 模块职责
    - [ ] 3.4.6 线程模型
    - [ ] 3.4.7 模块流程
    - [ ] 3.4.8 流程总结
  - [ ] 3.5 延时消息
    - [ ] 3.5.1 功能用例
    - [ ] 3.5.2 接口测试
    - [ ] 3.5.3 数据流程
    - [ ] 3.5.4 全局流程
    - [ ] 3.5.5 模块职责
    - [ ] 3.5.6 线程模型
    - [ ] 3.5.7 模块流程
    - [ ] 3.5.8 流程总结
  - [ ] 3.6 顺序消息
    - [ ] 3.6.1 设计原理
    - [ ] 3.6.2 实现流程
- [ ] 4 单机支撑体系
  - [ ] 4.1 框架支撑
    - [ ] 4.1.1 组件化体系
    - [ ] 4.1.2 简易运行容器
    - [ ] 4.1.3 依赖管理支持
    - [ ] 4.1.4 工具体系支撑
    - [ ] 4.1.5 分层规则约定
  - [ ] 4.2 broker模块
    - [ ] 4.2.1 模块架构
    - [ ] 4.2.2 启动流程
    - [ ] 4.2.3 接口层
    - [ ] 4.2.4 server
    - [ ] 4.2.5 领域层
      - [ ] 4.2.5.1 meta路由
      - [ ] 4.2.5.2 consumer
      - [ ] 4.2.5.3 producer
      - [ ] 4.2.5.4 timer
      - [ ] 4.2.5.5 transaction
    - [ ] 4.2.6 基础设置
      - [ ] 4.2.6.1 存储门面实现
      - [ ] 4.2.6.2 任务绑定实现
  - [ ] 4.3 store模块
    - [ ] 4.3.1 模块架构
    - [ ] 4.3.2 启动流程
    - [ ] 4.3.3 接口层
    - [ ] 4.3.4 领域层
      - [ ] 4.3.4.1 MQ封装实现
      - [ ] 4.3.4.2 CommitLog
      - [ ] 4.3.4.3 CommitEvent分发
      - [ ] 4.3.4.4 ConsumeQueue
      - [ ] 4.3.4.5 index
      - [ ] 4.3.4.6 meta
      - [ ] 4.3.4.7 timer
    - [ ] 4.3.5 基础设置
      - [ ] 4.3.5.1 MMAP
      - [ ] 4.3.5.2 TransientPool
- [ ] 5 分布式机制
  - [ ] 5.1 网络实现
  - [ ] 5.2 Registry
  - [ ] 5.3 注册机制
  - [ ] 5.4 master/slave
  - [ ] 5.5 扩展及未来
- [ ] 6 深入学习
  - [ ] 6.1 软件架构学习
  - [ ] 6.2 软件依赖应用
  - [ ] 6.3 软件工程实践
  - [ ] 6.4 编程语言经验
  - [ ] 6.5 编程思想沉淀
